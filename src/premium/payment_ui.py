"""
Payment UI and inline keyboards for the AI Companion Telegram bot.
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

from src.premium.subscription_manager import SubscriptionManager, PlanType, FeatureType
from src.premium.razorpay_integration import RazorpayIntegration


class PaymentUI:
    """Handles payment-related UI components and interactions."""
    
    def __init__(self, subscription_manager: SubscriptionManager, 
                 razorpay_integration: RazorpayIntegration):
        self.subscription_manager = subscription_manager
        self.razorpay_integration = razorpay_integration
        self.logger = logging.getLogger(__name__)
        
        # UI text templates
        self.ui_texts = {
            "plan_selection": "ğŸ¯ **Choose Your AI Companion Plan**\\n\\n"
                            "Select the perfect plan for your needs:",
            "plan_details": "ğŸ“‹ **Plan Details**\\n\\n"
                          "**{plan_name}**\\n"
                          "ğŸ’° Price: {price}\\n"
                          "â° Duration: {duration}\\n"
                          "ğŸ’¬ Messages: {messages}\\n\\n"
                          "**Features:**\\n{features}\\n\\n"
                          "{description}",
            "payment_processing": "â³ **Processing Payment**\\n\\n"
                                "Please wait while we process your payment...",
            "payment_success": "âœ… **Payment Successful!**\\n\\n"
                             "Welcome to {plan_name}!\\n"
                             "Your subscription is now active.\\n\\n"
                             "ğŸ‰ You now have access to all premium features!",
            "payment_failed": "âŒ **Payment Failed**\\n\\n"
                            "We couldn't process your payment.\\n"
                            "Please try again or contact support.\\n\\n"
                            "Error: {error}",
            "subscription_status": "ğŸ“Š **Your Subscription**\\n\\n"
                                 "**Plan:** {plan_name}\\n"
                                 "**Status:** {status}\\n"
                                 "**Expires:** {expires}\\n"
                                 "**Messages Used:** {messages_used}\\n\\n"
                                 "**Available Features:**\\n{features}",
            "upgrade_prompt": "ğŸš€ **Upgrade Your Plan**\\n\\n"
                            "You're currently on the {current_plan}.\\n"
                            "Upgrade to unlock more features!",
            "feature_locked": "ğŸ”’ **Premium Feature**\\n\\n"
                            "This feature requires a premium subscription.\\n"
                            "Upgrade now to unlock {feature_name}!"
        }
        
        self.logger.info("Payment UI initialized")
    
    def create_plan_selection_keyboard(self, current_plan: Optional[PlanType] = None) -> InlineKeyboardMarkup:
        """Create inline keyboard for plan selection."""
        keyboard = []
        
        # Get all available plans
        plans = self.subscription_manager.get_all_plans()
        
        for plan in plans:
            # Skip current plan
            if current_plan and plan.plan_type == current_plan:
                continue
            
            # Format button text
            button_text = f\"{plan.name} - {self._format_price(plan.price, plan.currency)}\"\n            \n            # Add emoji indicators\n            if plan.plan_type == PlanType.FREE:\n                button_text = f\"ğŸ†“ {button_text}\"\n            elif plan.plan_type == PlanType.BASIC:\n                button_text = f\"â­ {button_text}\"\n            elif plan.plan_type == PlanType.PREMIUM:\n                button_text = f\"ğŸ’ {button_text}\"\n            elif plan.plan_type == PlanType.LIFETIME:\n                button_text = f\"ğŸ† {button_text}\"\n            \n            keyboard.append([\n                InlineKeyboardButton(\n                    button_text,\n                    callback_data=f\"plan_details:{plan.plan_type.value}\"\n                )\n            ])\n        \n        # Add management options\n        keyboard.append([\n            InlineKeyboardButton(\"ğŸ“Š My Subscription\", callback_data=\"subscription_status\"),\n            InlineKeyboardButton(\"â“ Help\", callback_data=\"payment_help\")\n        ])\n        \n        return InlineKeyboardMarkup(keyboard)\n    \n    def create_plan_details_keyboard(self, plan_type: PlanType, \n                                   user_current_plan: Optional[PlanType] = None) -> InlineKeyboardMarkup:\n        \"\"\"Create inline keyboard for plan details.\"\"\"\n        keyboard = []\n        \n        # Purchase/Upgrade button\n        if user_current_plan != plan_type:\n            action_text = \"Upgrade\" if user_current_plan else \"Subscribe\"\n            keyboard.append([\n                InlineKeyboardButton(\n                    f\"ğŸ›’ {action_text} Now\",\n                    callback_data=f\"purchase_plan:{plan_type.value}\"\n                )\n            ])\n        \n        # Compare plans button\n        keyboard.append([\n            InlineKeyboardButton(\"ğŸ“Š Compare Plans\", callback_data=\"compare_plans\")\n        ])\n        \n        # Navigation buttons\n        keyboard.append([\n            InlineKeyboardButton(\"â¬…ï¸ Back to Plans\", callback_data=\"plan_selection\"),\n            InlineKeyboardButton(\"âŒ Close\", callback_data=\"close_menu\")\n        ])\n        \n        return InlineKeyboardMarkup(keyboard)\n    \n    def create_payment_confirmation_keyboard(self, plan_type: PlanType, \n                                           order_id: str) -> InlineKeyboardMarkup:\n        \"\"\"Create inline keyboard for payment confirmation.\"\"\"\n        keyboard = [\n            [\n                InlineKeyboardButton(\n                    \"ğŸ’³ Pay Now\",\n                    url=f\"https://rzp.io/l/{order_id}\"  # Razorpay payment link\n                )\n            ],\n            [\n                InlineKeyboardButton(\"âœ… I've Paid\", callback_data=f\"verify_payment:{order_id}\"),\n                InlineKeyboardButton(\"âŒ Cancel\", callback_data=\"cancel_payment\")\n            ]\n        ]\n        \n        return InlineKeyboardMarkup(keyboard)\n    \n    def create_subscription_management_keyboard(self, subscription_plan: PlanType) -> InlineKeyboardMarkup:\n        \"\"\"Create inline keyboard for subscription management.\"\"\"\n        keyboard = []\n        \n        # Upgrade option (if not on highest plan)\n        if subscription_plan != PlanType.LIFETIME:\n            keyboard.append([\n                InlineKeyboardButton(\"ğŸš€ Upgrade Plan\", callback_data=\"plan_selection\")\n            ])\n        \n        # Renewal option (for expired subscriptions)\n        keyboard.append([\n            InlineKeyboardButton(\"ğŸ”„ Renew Subscription\", callback_data=f\"renew_plan:{subscription_plan.value}\")\n        ])\n        \n        # Support and help\n        keyboard.append([\n            InlineKeyboardButton(\"ğŸ“ Contact Support\", callback_data=\"contact_support\"),\n            InlineKeyboardButton(\"ğŸ“‹ Usage Stats\", callback_data=\"usage_stats\")\n        ])\n        \n        # Navigation\n        keyboard.append([\n            InlineKeyboardButton(\"â¬…ï¸ Back to Plans\", callback_data=\"plan_selection\"),\n            InlineKeyboardButton(\"âŒ Close\", callback_data=\"close_menu\")\n        ])\n        \n        return InlineKeyboardMarkup(keyboard)\n    \n    def create_feature_upgrade_keyboard(self, required_feature: FeatureType) -> InlineKeyboardMarkup:\n        \"\"\"Create inline keyboard for feature upgrade prompt.\"\"\"\n        # Get plans that include the required feature\n        plans_with_feature = self.subscription_manager.get_plans_with_feature(required_feature)\n        \n        keyboard = []\n        \n        # Add upgrade options\n        for plan in plans_with_feature[:2]:  # Show top 2 options\n            keyboard.append([\n                InlineKeyboardButton(\n                    f\"ğŸš€ Upgrade to {plan.name}\",\n                    callback_data=f\"purchase_plan:{plan.plan_type.value}\"\n                )\n            ])\n        \n        # View all plans\n        keyboard.append([\n            InlineKeyboardButton(\"ğŸ“‹ View All Plans\", callback_data=\"plan_selection\")\n        ])\n        \n        # Close option\n        keyboard.append([\n            InlineKeyboardButton(\"âŒ Maybe Later\", callback_data=\"close_menu\")\n        ])\n        \n        return InlineKeyboardMarkup(keyboard)\n    \n    async def show_plan_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n        \"\"\"Show plan selection menu.\"\"\"\n        try:\n            user_id = str(update.effective_user.id)\n            \n            # Get user's current subscription\n            current_subscription = await context.bot_data.get('database').get_user_subscription(user_id)\n            current_plan = current_subscription.plan_type if current_subscription else None\n            \n            # Create keyboard\n            keyboard = self.create_plan_selection_keyboard(current_plan)\n            \n            # Send or edit message\n            text = self.ui_texts[\"plan_selection\"]\n            \n            if update.callback_query:\n                await update.callback_query.edit_message_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n            else:\n                await update.message.reply_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n                \n        except Exception as e:\n            self.logger.error(f\"Error showing plan selection: {e}\")\n            await self._send_error_message(update, \"Failed to load plans. Please try again.\")\n    \n    async def show_plan_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE, \n                              plan_type: PlanType) -> None:\n        \"\"\"Show detailed information about a specific plan.\"\"\"\n        try:\n            user_id = str(update.effective_user.id)\n            \n            # Get plan details\n            plan = self.subscription_manager.get_plan(plan_type)\n            if not plan:\n                await self._send_error_message(update, \"Plan not found.\")\n                return\n            \n            # Get user's current subscription\n            current_subscription = await context.bot_data.get('database').get_user_subscription(user_id)\n            current_plan = current_subscription.plan_type if current_subscription else None\n            \n            # Format plan details\n            features_text = \"\\n\".join([f\"âœ… {self._format_feature(f)}\" for f in plan.features])\n            \n            text = self.ui_texts[\"plan_details\"].format(\n                plan_name=plan.name,\n                price=self._format_price(plan.price, plan.currency),\n                duration=self._format_duration(plan.duration_days),\n                messages=\"Unlimited\" if plan.message_limit == -1 else str(plan.message_limit),\n                features=features_text,\n                description=plan.description\n            )\n            \n            # Create keyboard\n            keyboard = self.create_plan_details_keyboard(plan_type, current_plan)\n            \n            # Edit message\n            await update.callback_query.edit_message_text(\n                text=text,\n                reply_markup=keyboard,\n                parse_mode='Markdown'\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Error showing plan details: {e}\")\n            await self._send_error_message(update, \"Failed to load plan details.\")\n    \n    async def initiate_payment(self, update: Update, context: ContextTypes.DEFAULT_TYPE, \n                             plan_type: PlanType) -> None:\n        \"\"\"Initiate payment process for a plan.\"\"\"\n        try:\n            user_id = str(update.effective_user.id)\n            \n            # Get plan details\n            plan = self.subscription_manager.get_plan(plan_type)\n            if not plan:\n                await self._send_error_message(update, \"Plan not found.\")\n                return\n            \n            # Create payment order\n            order_result = await self.razorpay_integration.create_payment_order(\n                amount=plan.price,\n                user_id=user_id,\n                plan_type=plan_type.value,\n                currency=plan.currency\n            )\n            \n            if not order_result:\n                await self._send_error_message(update, \"Failed to create payment order.\")\n                return\n            \n            # Create payment confirmation keyboard\n            keyboard = self.create_payment_confirmation_keyboard(\n                plan_type, order_result[\"order_id\"]\n            )\n            \n            # Send payment message\n            text = f\"ğŸ’³ **Payment for {plan.name}**\\n\\n\" \\\n                   f\"Amount: {self._format_price(plan.price, plan.currency)}\\n\" \\\n                   f\"Order ID: `{order_result['order_id']}`\\n\\n\" \\\n                   f\"Click 'Pay Now' to complete your payment.\"\n            \n            await update.callback_query.edit_message_text(\n                text=text,\n                reply_markup=keyboard,\n                parse_mode='Markdown'\n            )\n            \n            # Store order details in context\n            context.user_data['pending_order'] = {\n                'order_id': order_result['order_id'],\n                'plan_type': plan_type.value,\n                'amount': plan.price\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error initiating payment: {e}\")\n            await self._send_error_message(update, \"Failed to initiate payment.\")\n    \n    async def show_subscription_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n        \"\"\"Show user's current subscription status.\"\"\"\n        try:\n            user_id = str(update.effective_user.id)\n            \n            # Get user subscription\n            subscription = await context.bot_data.get('database').get_user_subscription(user_id)\n            \n            if not subscription:\n                text = \"ğŸ“‹ **No Active Subscription**\\n\\n\" \\\n                       \"You don't have an active subscription yet.\\n\" \\\n                       \"Choose a plan to get started!\"\n                keyboard = self.create_plan_selection_keyboard()\n            else:\n                # Get plan details\n                plan = self.subscription_manager.get_plan(subscription.plan_type)\n                \n                # Format subscription info\n                status = \"Active\" if subscription.is_active and not subscription.is_expired() else \"Expired\"\n                expires = \"Never\" if not subscription.expires_at else subscription.expires_at.strftime(\"%Y-%m-%d\")\n                \n                # Get message usage (placeholder)\n                messages_used = \"N/A\"  # This would come from actual usage tracking\n                \n                # Format features\n                features = self.subscription_manager.get_user_feature_list(subscription)\n                features_text = \"\\n\".join([f\"âœ… {self._format_feature(f)}\" for f in features])\n                \n                text = self.ui_texts[\"subscription_status\"].format(\n                    plan_name=plan.name if plan else \"Unknown\",\n                    status=status,\n                    expires=expires,\n                    messages_used=messages_used,\n                    features=features_text\n                )\n                \n                keyboard = self.create_subscription_management_keyboard(subscription.plan_type)\n            \n            # Send or edit message\n            if update.callback_query:\n                await update.callback_query.edit_message_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n            else:\n                await update.message.reply_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n                \n        except Exception as e:\n            self.logger.error(f\"Error showing subscription status: {e}\")\n            await self._send_error_message(update, \"Failed to load subscription status.\")\n    \n    async def show_feature_locked_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE, \n                                        feature: FeatureType) -> None:\n        \"\"\"Show feature locked message with upgrade options.\"\"\"\n        try:\n            feature_name = self._format_feature(feature)\n            \n            text = self.ui_texts[\"feature_locked\"].format(feature_name=feature_name)\n            keyboard = self.create_feature_upgrade_keyboard(feature)\n            \n            if update.callback_query:\n                await update.callback_query.edit_message_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n            else:\n                await update.message.reply_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n                \n        except Exception as e:\n            self.logger.error(f\"Error showing feature locked message: {e}\")\n    \n    async def handle_payment_success(self, update: Update, context: ContextTypes.DEFAULT_TYPE, \n                                   plan_type: PlanType) -> None:\n        \"\"\"Handle successful payment notification.\"\"\"\n        try:\n            plan = self.subscription_manager.get_plan(plan_type)\n            \n            text = self.ui_texts[\"payment_success\"].format(\n                plan_name=plan.name if plan else \"Premium Plan\"\n            )\n            \n            keyboard = InlineKeyboardMarkup([\n                [InlineKeyboardButton(\"ğŸ‰ Start Using Features\", callback_data=\"close_menu\")],\n                [InlineKeyboardButton(\"ğŸ“Š View Subscription\", callback_data=\"subscription_status\")]\n            ])\n            \n            if update.callback_query:\n                await update.callback_query.edit_message_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n            else:\n                await update.message.reply_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n                \n        except Exception as e:\n            self.logger.error(f\"Error handling payment success: {e}\")\n    \n    async def handle_payment_failure(self, update: Update, context: ContextTypes.DEFAULT_TYPE, \n                                   error_message: str = \"Unknown error\") -> None:\n        \"\"\"Handle payment failure notification.\"\"\"\n        try:\n            text = self.ui_texts[\"payment_failed\"].format(error=error_message)\n            \n            keyboard = InlineKeyboardMarkup([\n                [InlineKeyboardButton(\"ğŸ”„ Try Again\", callback_data=\"plan_selection\")],\n                [InlineKeyboardButton(\"ğŸ“ Contact Support\", callback_data=\"contact_support\")]\n            ])\n            \n            if update.callback_query:\n                await update.callback_query.edit_message_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n            else:\n                await update.message.reply_text(\n                    text=text,\n                    reply_markup=keyboard,\n                    parse_mode='Markdown'\n                )\n                \n        except Exception as e:\n            self.logger.error(f\"Error handling payment failure: {e}\")\n    \n    def _format_price(self, price: int, currency: str) -> str:\n        \"\"\"Format price for display.\"\"\"\n        if price == 0:\n            return \"Free\"\n        \n        if currency == \"INR\":\n            rupees = price / 100\n            return f\"â‚¹{rupees:,.0f}\"\n        \n        return f\"{price / 100:.2f} {currency}\"\n    \n    def _format_duration(self, duration_days: int) -> str:\n        \"\"\"Format duration for display.\"\"\"\n        if duration_days == -1:\n            return \"Lifetime\"\n        elif duration_days == 30:\n            return \"Monthly\"\n        elif duration_days == 365:\n            return \"Yearly\"\n        else:\n            return f\"{duration_days} days\"\n    \n    def _format_feature(self, feature: FeatureType) -> str:\n        \"\"\"Format feature for display.\"\"\"\n        feature_names = {\n            FeatureType.BASIC_CHAT: \"Basic Chat\",\n            FeatureType.UNLIMITED_MESSAGES: \"Unlimited Messages\",\n            FeatureType.VOICE_CLONING: \"Voice Cloning\",\n            FeatureType.IMAGE_GENERATION: \"Image Generation\",\n            FeatureType.PROACTIVE_MESSAGING: \"Proactive Messaging\",\n            FeatureType.PRIORITY_SUPPORT: \"Priority Support\"\n        }\n        \n        return feature_names.get(feature, feature.value.replace(\"_\", \" \").title())\n    \n    async def _send_error_message(self, update: Update, message: str) -> None:\n        \"\"\"Send error message to user.\"\"\"\n        try:\n            error_text = f\"âŒ **Error**\\n\\n{message}\"\n            \n            if update.callback_query:\n                await update.callback_query.edit_message_text(\n                    text=error_text,\n                    parse_mode='Markdown'\n                )\n            else:\n                await update.message.reply_text(\n                    text=error_text,\n                    parse_mode='Markdown'\n                )\n        except Exception as e:\n            self.logger.error(f\"Error sending error message: {e}\")\n\n\nclass PaymentCallbackHandler:\n    \"\"\"Handles payment-related callback queries.\"\"\"\n    \n    def __init__(self, payment_ui: PaymentUI, subscription_manager: SubscriptionManager):\n        self.payment_ui = payment_ui\n        self.subscription_manager = subscription_manager\n        self.logger = logging.getLogger(__name__)\n    \n    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n        \"\"\"Handle payment-related callback queries.\"\"\"\n        try:\n            query = update.callback_query\n            await query.answer()\n            \n            callback_data = query.data\n            \n            if callback_data == \"plan_selection\":\n                await self.payment_ui.show_plan_selection(update, context)\n            \n            elif callback_data.startswith(\"plan_details:\"):\n                plan_type_str = callback_data.split(\":\")[1]\n                plan_type = PlanType(plan_type_str)\n                await self.payment_ui.show_plan_details(update, context, plan_type)\n            \n            elif callback_data.startswith(\"purchase_plan:\"):\n                plan_type_str = callback_data.split(\":\")[1]\n                plan_type = PlanType(plan_type_str)\n                await self.payment_ui.initiate_payment(update, context, plan_type)\n            \n            elif callback_data == \"subscription_status\":\n                await self.payment_ui.show_subscription_status(update, context)\n            \n            elif callback_data.startswith(\"verify_payment:\"):\n                order_id = callback_data.split(\":\")[1]\n                await self._handle_payment_verification(update, context, order_id)\n            \n            elif callback_data == \"cancel_payment\":\n                await self._handle_payment_cancellation(update, context)\n            \n            elif callback_data == \"close_menu\":\n                await query.delete_message()\n            \n            elif callback_data == \"contact_support\":\n                await self._show_support_info(update, context)\n            \n            else:\n                self.logger.warning(f\"Unhandled payment callback: {callback_data}\")\n                \n        except Exception as e:\n            self.logger.error(f\"Error handling payment callback: {e}\")\n    \n    async def _handle_payment_verification(self, update: Update, context: ContextTypes.DEFAULT_TYPE, \n                                         order_id: str) -> None:\n        \"\"\"Handle payment verification request.\"\"\"\n        try:\n            # This would typically check with Razorpay API\n            # For now, show a processing message\n            await update.callback_query.edit_message_text(\n                text=\"â³ **Verifying Payment**\\n\\nPlease wait while we verify your payment...\",\n                parse_mode='Markdown'\n            )\n            \n            # In a real implementation, you would:\n            # 1. Check payment status with Razorpay\n            # 2. Update user subscription if payment is successful\n            # 3. Show appropriate success/failure message\n            \n        except Exception as e:\n            self.logger.error(f\"Error verifying payment: {e}\")\n    \n    async def _handle_payment_cancellation(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n        \"\"\"Handle payment cancellation.\"\"\"\n        try:\n            await update.callback_query.edit_message_text(\n                text=\"âŒ **Payment Cancelled**\\n\\nYour payment has been cancelled. You can try again anytime.\",\n                reply_markup=InlineKeyboardMarkup([\n                    [InlineKeyboardButton(\"ğŸ”„ Try Again\", callback_data=\"plan_selection\")]\n                ]),\n                parse_mode='Markdown'\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Error handling payment cancellation: {e}\")\n    \n    async def _show_support_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n        \"\"\"Show support contact information.\"\"\"\n        try:\n            support_text = \"ğŸ“ **Contact Support**\\n\\n\" \\\n                          \"Need help with your subscription?\\n\\n\" \\\n                          \"ğŸ“§ Email: support@aicompanion.com\\n\" \\\n                          \"ğŸ’¬ Telegram: @aicompanion_support\\n\" \\\n                          \"ğŸ• Hours: 9 AM - 6 PM IST\\n\\n\" \\\n                          \"We're here to help!\"\n            \n            await update.callback_query.edit_message_text(\n                text=support_text,\n                reply_markup=InlineKeyboardMarkup([\n                    [InlineKeyboardButton(\"â¬…ï¸ Back\", callback_data=\"plan_selection\")]\n                ]),\n                parse_mode='Markdown'\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Error showing support info: {e}\")\n"