"""
Contextual image generator that automatically creates images during conversations
based on emotional context, memory triggers, and user requests.
"""

import logging
import asyncio
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
import re

from src.image.image_generation_engine import ImageGenerationEngine
from src.premium.access_control import FeatureAccessControl, FeatureType
from src.core.interfaces import DatabaseInterface


class ContextualImageGenerator:
    \"\"\"Handles automatic and contextual image generation during conversations.\"\"\"\n    \n    def __init__(self, image_engine: ImageGenerationEngine, \n                 access_control: FeatureAccessControl,\n                 database: DatabaseInterface):\n        self.image_engine = image_engine\n        self.access_control = access_control\n        self.database = database\n        self.logger = logging.getLogger(__name__)\n        \n        # Conversation triggers for automatic image generation\n        self.auto_triggers = {\n            \"memory_triggers\": [\n                r\"remember when\",\n                r\"do you recall\",\n                r\"that time when\",\n                r\"i miss\",\n                r\"thinking about\",\n                r\"reminds me of\",\n                r\"nostalgic\",\n                r\"back then\"\n            ],\n            \"romantic_triggers\": [\n                r\"i love you\",\n                r\"you're beautiful\",\n                r\"romantic\",\n                r\"kiss\",\n                r\"hug\",\n                r\"together\",\n                r\"date\",\n                r\"intimate\",\n                r\"close to you\"\n            ],\n            \"emotional_triggers\": [\n                r\"feeling\",\n                r\"emotional\",\n                r\"heart\",\n                r\"soul\",\n                r\"deep\",\n                r\"meaningful\",\n                r\"special moment\",\n                r\"touching\"\n            ],\n            \"request_triggers\": [\n                r\"show me\",\n                r\"picture of\",\n                r\"image of\",\n                r\"visualize\",\n                r\"imagine\",\n                r\"draw\",\n                r\"create.*image\",\n                r\"generate.*picture\"\n            ]\n        }\n        \n        # Rate limiting for automatic generation\n        self.user_generation_history = {}\n        self.auto_generation_cooldown = 300  # 5 minutes between auto generations\n        self.max_auto_generations_per_day = 5\n        \n        # Context analysis patterns\n        self.context_patterns = {\n            \"memory_context\": {\n                \"patterns\": [r\"when we\", r\"our\", r\"together\", r\"shared\"],\n                \"image_type\": \"nostalgic\",\n                \"confidence_threshold\": 0.7\n            },\n            \"romantic_context\": {\n                \"patterns\": [r\"love\", r\"romantic\", r\"beautiful\", r\"gorgeous\"],\n                \"image_type\": \"romantic\",\n                \"confidence_threshold\": 0.6\n            },\n            \"intimate_context\": {\n                \"patterns\": [r\"close\", r\"intimate\", r\"personal\", r\"private\"],\n                \"image_type\": \"intimate\",\n                \"confidence_threshold\": 0.8\n            },\n            \"playful_context\": {\n                \"patterns\": [r\"fun\", r\"playful\", r\"silly\", r\"laugh\", r\"happy\"],\n                \"image_type\": \"playful\",\n                \"confidence_threshold\": 0.6\n            }\n        }\n        \n        self.logger.info(\"Contextual Image Generator initialized\")\n    \n    async def analyze_conversation_for_images(self, user_id: str, user_message: str, \n                                            ai_response: str) -> Dict[str, Any]:\n        \"\"\"Analyze conversation to determine if image generation is appropriate.\"\"\"\n        try:\n            self.logger.info(f\"Analyzing conversation for image opportunities: user {user_id}\")\n            \n            # Check if user has image generation access\n            access_info = await self.access_control.check_feature_access(\n                user_id, FeatureType.IMAGE_GENERATION\n            )\n            \n            if not access_info[\"has_access\"]:\n                return {\n                    \"should_generate\": False,\n                    \"reason\": \"no_access\",\n                    \"access_info\": access_info\n                }\n            \n            # Check rate limiting\n            rate_limit_check = await self._check_rate_limits(user_id)\n            if not rate_limit_check[\"allowed\"]:\n                return {\n                    \"should_generate\": False,\n                    \"reason\": \"rate_limited\",\n                    \"rate_limit_info\": rate_limit_check\n                }\n            \n            # Analyze conversation content\n            conversation_text = f\"{user_message} {ai_response}\"\n            \n            # Check for explicit image requests\n            explicit_request = await self._detect_explicit_image_request(conversation_text)\n            if explicit_request[\"detected\"]:\n                return {\n                    \"should_generate\": True,\n                    \"generation_type\": \"explicit_request\",\n                    \"image_type\": explicit_request[\"image_type\"],\n                    \"context\": explicit_request[\"context\"],\n                    \"confidence\": 1.0\n                }\n            \n            # Check for automatic triggers\n            auto_trigger = await self._detect_auto_triggers(conversation_text)\n            if auto_trigger[\"detected\"]:\n                return {\n                    \"should_generate\": True,\n                    \"generation_type\": \"automatic\",\n                    \"image_type\": auto_trigger[\"image_type\"],\n                    \"trigger_type\": auto_trigger[\"trigger_type\"],\n                    \"context\": conversation_text,\n                    \"confidence\": auto_trigger[\"confidence\"]\n                }\n            \n            # Check for contextual opportunities\n            contextual_analysis = await self._analyze_contextual_opportunities(\n                user_id, conversation_text\n            )\n            if contextual_analysis[\"should_generate\"]:\n                return {\n                    \"should_generate\": True,\n                    \"generation_type\": \"contextual\",\n                    \"image_type\": contextual_analysis[\"image_type\"],\n                    \"context\": conversation_text,\n                    \"confidence\": contextual_analysis[\"confidence\"],\n                    \"contextual_elements\": contextual_analysis[\"elements\"]\n                }\n            \n            return {\n                \"should_generate\": False,\n                \"reason\": \"no_suitable_context\",\n                \"analysis\": {\n                    \"explicit_request\": explicit_request,\n                    \"auto_trigger\": auto_trigger,\n                    \"contextual_analysis\": contextual_analysis\n                }\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing conversation for images: {e}\")\n            return {\n                \"should_generate\": False,\n                \"reason\": \"analysis_error\",\n                \"error\": str(e)\n            }\n    \n    async def generate_contextual_image(self, user_id: str, analysis_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Generate image based on conversation analysis.\"\"\"\n        try:\n            generation_type = analysis_result[\"generation_type\"]\n            image_type = analysis_result[\"image_type\"]\n            context = analysis_result[\"context\"]\n            \n            self.logger.info(\n                f\"Generating contextual image for user {user_id}, \"\n                f\"type: {generation_type}, image_type: {image_type}\"\n            )\n            \n            # Choose generation method based on type\n            if generation_type == \"explicit_request\":\n                result = await self._handle_explicit_request(user_id, context, image_type)\n            elif generation_type == \"automatic\":\n                result = await self._handle_automatic_generation(user_id, context, image_type, analysis_result)\n            elif generation_type == \"contextual\":\n                result = await self._handle_contextual_generation(user_id, context, image_type, analysis_result)\n            else:\n                raise Exception(f\"Unknown generation type: {generation_type}\")\n            \n            # Update generation history\n            if result.get(\"success\"):\n                await self._update_generation_history(user_id, generation_type, image_type)\n            \n            return result\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating contextual image: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"error_type\": \"contextual_generation_failed\"\n            }\n    \n    async def suggest_image_generation(self, user_id: str, conversation_context: str) -> Dict[str, Any]:\n        \"\"\"Suggest image generation opportunities to the user.\"\"\"\n        try:\n            # Analyze conversation for potential image opportunities\n            analysis = await self.analyze_conversation_for_images(\n                user_id, conversation_context, \"\"\n            )\n            \n            if not analysis[\"should_generate\"]:\n                return {\n                    \"has_suggestions\": False,\n                    \"reason\": analysis[\"reason\"]\n                }\n            \n            # Generate suggestions based on analysis\n            suggestions = []\n            \n            if analysis[\"generation_type\"] == \"contextual\":\n                suggestions.append({\n                    \"type\": \"contextual\",\n                    \"description\": f\"I could create a {analysis['image_type']} image based on our conversation\",\n                    \"image_type\": analysis[\"image_type\"],\n                    \"confidence\": analysis[\"confidence\"]\n                })\n            \n            # Add memory-based suggestions\n            memory_suggestions = await self._get_memory_based_suggestions(user_id)\n            suggestions.extend(memory_suggestions)\n            \n            # Add custom prompt suggestion\n            suggestions.append({\n                \"type\": \"custom\",\n                \"description\": \"Or tell me what specific image you'd like me to create\",\n                \"image_type\": \"custom\",\n                \"confidence\": 1.0\n            })\n            \n            return {\n                \"has_suggestions\": True,\n                \"suggestions\": suggestions,\n                \"analysis\": analysis\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating image suggestions: {e}\")\n            return {\n                \"has_suggestions\": False,\n                \"error\": str(e)\n            }\n    \n    async def _detect_explicit_image_request(self, text: str) -> Dict[str, Any]:\n        \"\"\"Detect explicit image generation requests.\"\"\"\n        text_lower = text.lower()\n        \n        for trigger in self.auto_triggers[\"request_triggers\"]:\n            if re.search(trigger, text_lower):\n                # Try to extract what they want to see\n                context = self._extract_image_context(text, trigger)\n                image_type = self._determine_image_type_from_context(context)\n                \n                return {\n                    \"detected\": True,\n                    \"trigger\": trigger,\n                    \"context\": context,\n                    \"image_type\": image_type\n                }\n        \n        return {\"detected\": False}\n    \n    async def _detect_auto_triggers(self, text: str) -> Dict[str, Any]:\n        \"\"\"Detect automatic generation triggers.\"\"\"\n        text_lower = text.lower()\n        \n        for trigger_type, triggers in self.auto_triggers.items():\n            if trigger_type == \"request_triggers\":  # Skip explicit requests\n                continue\n                \n            for trigger in triggers:\n                if re.search(trigger, text_lower):\n                    image_type = self._map_trigger_to_image_type(trigger_type)\n                    confidence = self._calculate_trigger_confidence(text, trigger)\n                    \n                    return {\n                        \"detected\": True,\n                        \"trigger_type\": trigger_type,\n                        \"trigger\": trigger,\n                        \"image_type\": image_type,\n                        \"confidence\": confidence\n                    }\n        \n        return {\"detected\": False}\n    \n    async def _analyze_contextual_opportunities(self, user_id: str, text: str) -> Dict[str, Any]:\n        \"\"\"Analyze text for contextual image generation opportunities.\"\"\"\n        text_lower = text.lower()\n        best_match = None\n        best_confidence = 0\n        \n        for context_type, context_info in self.context_patterns.items():\n            confidence = 0\n            matched_patterns = []\n            \n            for pattern in context_info[\"patterns\"]:\n                if re.search(pattern, text_lower):\n                    confidence += 0.2\n                    matched_patterns.append(pattern)\n            \n            # Boost confidence based on conversation history\n            history_boost = await self._get_conversation_history_boost(user_id, context_type)\n            confidence += history_boost\n            \n            if confidence >= context_info[\"confidence_threshold\"] and confidence > best_confidence:\n                best_confidence = confidence\n                best_match = {\n                    \"context_type\": context_type,\n                    \"image_type\": context_info[\"image_type\"],\n                    \"confidence\": confidence,\n                    \"matched_patterns\": matched_patterns\n                }\n        \n        if best_match:\n            return {\n                \"should_generate\": True,\n                \"image_type\": best_match[\"image_type\"],\n                \"confidence\": best_match[\"confidence\"],\n                \"elements\": best_match[\"matched_patterns\"]\n            }\n        \n        return {\"should_generate\": False}\n    \n    async def _handle_explicit_request(self, user_id: str, context: str, image_type: str) -> Dict[str, Any]:\n        \"\"\"Handle explicit image generation request.\"\"\"\n        return await self.image_engine.generate_contextual_image(user_id, context, image_type)\n    \n    async def _handle_automatic_generation(self, user_id: str, context: str, \n                                         image_type: str, analysis: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle automatic image generation.\"\"\"\n        trigger_type = analysis.get(\"trigger_type\", \"\")\n        \n        if trigger_type == \"memory_triggers\":\n            # Extract memory topic and generate memory-based image\n            memory_topic = self._extract_memory_topic(context)\n            if memory_topic:\n                return await self.image_engine.generate_memory_image(user_id, memory_topic)\n        \n        # Default to contextual generation\n        return await self.image_engine.generate_contextual_image(user_id, context, image_type)\n    \n    async def _handle_contextual_generation(self, user_id: str, context: str, \n                                          image_type: str, analysis: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle contextual image generation.\"\"\"\n        return await self.image_engine.generate_conversation_image(user_id, context)\n    \n    async def _check_rate_limits(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Check rate limits for automatic image generation.\"\"\"\n        now = datetime.now()\n        \n        # Get user's generation history\n        if user_id not in self.user_generation_history:\n            self.user_generation_history[user_id] = []\n        \n        user_history = self.user_generation_history[user_id]\n        \n        # Remove old entries (older than 24 hours)\n        cutoff_time = now - timedelta(hours=24)\n        user_history[:] = [entry for entry in user_history if entry[\"timestamp\"] > cutoff_time]\n        \n        # Check daily limit\n        daily_count = len(user_history)\n        if daily_count >= self.max_auto_generations_per_day:\n            return {\n                \"allowed\": False,\n                \"reason\": \"daily_limit_exceeded\",\n                \"daily_count\": daily_count,\n                \"daily_limit\": self.max_auto_generations_per_day\n            }\n        \n        # Check cooldown\n        if user_history:\n            last_generation = max(user_history, key=lambda x: x[\"timestamp\"])\n            time_since_last = (now - last_generation[\"timestamp\"]).total_seconds()\n            \n            if time_since_last < self.auto_generation_cooldown:\n                return {\n                    \"allowed\": False,\n                    \"reason\": \"cooldown_active\",\n                    \"time_remaining\": self.auto_generation_cooldown - time_since_last\n                }\n        \n        return {\n            \"allowed\": True,\n            \"daily_count\": daily_count,\n            \"daily_limit\": self.max_auto_generations_per_day\n        }\n    \n    async def _update_generation_history(self, user_id: str, generation_type: str, image_type: str) -> None:\n        \"\"\"Update user's generation history.\"\"\"\n        if user_id not in self.user_generation_history:\n            self.user_generation_history[user_id] = []\n        \n        self.user_generation_history[user_id].append({\n            \"timestamp\": datetime.now(),\n            \"generation_type\": generation_type,\n            \"image_type\": image_type\n        })\n    \n    async def _get_memory_based_suggestions(self, user_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get memory-based image suggestions.\"\"\"\n        try:\n            # Get user's recent memories\n            recent_memories = await self.database.get_user_recent_memories(user_id, limit=3)\n            \n            suggestions = []\n            for memory in recent_memories:\n                suggestions.append({\n                    \"type\": \"memory\",\n                    \"description\": f\"Create an image based on: {memory.get('topic', 'a special memory')}\",\n                    \"image_type\": \"nostalgic\",\n                    \"memory_topic\": memory.get(\"topic\", \"\"),\n                    \"confidence\": 0.8\n                })\n            \n            return suggestions\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting memory suggestions: {e}\")\n            return []\n    \n    async def _get_conversation_history_boost(self, user_id: str, context_type: str) -> float:\n        \"\"\"Get confidence boost based on conversation history.\"\"\"\n        try:\n            # Get recent conversation history\n            recent_conversations = await self.database.get_recent_conversations(user_id, limit=10)\n            \n            # Count relevant context mentions\n            relevant_count = 0\n            for conv in recent_conversations:\n                conv_text = f\"{conv.get('user_message', '')} {conv.get('ai_response', '')}\".lower()\n                \n                context_info = self.context_patterns.get(context_type, {})\n                for pattern in context_info.get(\"patterns\", []):\n                    if re.search(pattern, conv_text):\n                        relevant_count += 1\n                        break\n            \n            # Return boost based on frequency (max 0.3)\n            return min(relevant_count * 0.05, 0.3)\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting conversation history boost: {e}\")\n            return 0.0\n    \n    def _extract_image_context(self, text: str, trigger: str) -> str:\n        \"\"\"Extract context for image generation from text.\"\"\"\n        # Simple extraction - in a real implementation, this would be more sophisticated\n        sentences = text.split('.')\n        for sentence in sentences:\n            if re.search(trigger, sentence.lower()):\n                return sentence.strip()\n        return text\n    \n    def _determine_image_type_from_context(self, context: str) -> str:\n        \"\"\"Determine image type from context.\"\"\"\n        context_lower = context.lower()\n        \n        if any(word in context_lower for word in [\"romantic\", \"love\", \"kiss\", \"hug\"]):\n            return \"romantic\"\n        elif any(word in context_lower for word in [\"memory\", \"remember\", \"past\"]):\n            return \"nostalgic\"\n        elif any(word in context_lower for word in [\"fun\", \"happy\", \"playful\"]):\n            return \"playful\"\n        elif any(word in context_lower for word in [\"intimate\", \"close\", \"personal\"]):\n            return \"intimate\"\n        else:\n            return \"romantic\"  # Default\n    \n    def _map_trigger_to_image_type(self, trigger_type: str) -> str:\n        \"\"\"Map trigger type to image type.\"\"\"\n        mapping = {\n            \"memory_triggers\": \"nostalgic\",\n            \"romantic_triggers\": \"romantic\",\n            \"emotional_triggers\": \"intimate\",\n            \"request_triggers\": \"romantic\"\n        }\n        return mapping.get(trigger_type, \"romantic\")\n    \n    def _calculate_trigger_confidence(self, text: str, trigger: str) -> float:\n        \"\"\"Calculate confidence for trigger match.\"\"\"\n        # Simple confidence calculation\n        matches = len(re.findall(trigger, text.lower()))\n        base_confidence = 0.6\n        \n        # Boost confidence for multiple matches\n        confidence = min(base_confidence + (matches - 1) * 0.1, 0.9)\n        \n        return confidence\n    \n    def _extract_memory_topic(self, text: str) -> Optional[str]:\n        \"\"\"Extract memory topic from text.\"\"\"\n        # Look for patterns like \"remember when we...\", \"that time we...\"\n        memory_patterns = [\n            r\"remember when we ([^.!?]+)\",\n            r\"that time we ([^.!?]+)\",\n            r\"when we ([^.!?]+)\",\n            r\"our ([^.!?]+)\"\n        ]\n        \n        for pattern in memory_patterns:\n            match = re.search(pattern, text.lower())\n            if match:\n                return match.group(1).strip()\n        \n        return None\n    \n    def get_generation_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get contextual generation statistics.\"\"\"\n        total_users = len(self.user_generation_history)\n        total_generations = sum(len(history) for history in self.user_generation_history.values())\n        \n        # Count by generation type\n        type_counts = {}\n        for user_history in self.user_generation_history.values():\n            for entry in user_history:\n                gen_type = entry[\"generation_type\"]\n                type_counts[gen_type] = type_counts.get(gen_type, 0) + 1\n        \n        return {\n            \"total_users_with_generations\": total_users,\n            \"total_contextual_generations\": total_generations,\n            \"generation_types\": type_counts,\n            \"rate_limits\": {\n                \"cooldown_seconds\": self.auto_generation_cooldown,\n                \"daily_limit\": self.max_auto_generations_per_day\n            }\n        }\n"